<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <title>我的號碼 - {{ ticket_id }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background: linear-gradient(135deg, #f5f7fa, #e4ebf5);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      .ticket-card {
        max-width: 420px;
        width: 100%;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
      .ticket-number {
        font-size: 3rem;
        font-weight: 700;
      }
      .label {
        color: #6c757d;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div class="card ticket-card">
      <div class="card-header bg-primary text-white">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <div class="small">叫號系統 - {{ service }}</div>
            <div class="fw-bold">我的號碼</div>
          </div>
          <span class="badge bg-light text-primary" id="status-badge"
            >載入中...</span
          >
        </div>
      </div>
      <div class="card-body">
        <div class="mb-3">
          <div class="label">票券編號 ticket_id</div>
          <div class="fw-semibold">{{ ticket_id }}</div>
        </div>

        <div class="mb-3">
          <div class="label">目前叫到號碼</div>
          <div class="fs-4 fw-bold" id="current-number">載入中...</div>
        </div>

        <div class="mb-3">
          <div class="label">我的號碼</div>
          <div class="ticket-number text-primary" id="my-number">載入中...</div>
        </div>

        <div class="mb-3">
          <div class="label">前面還有</div>
          <div class="fs-5"><span id="ahead-count">載入中...</span> 人</div>
        </div>

        <div class="mb-2" id="counter-info" style="display: none">
          <div class="alert alert-success py-2 px-3 mb-0">
            <div class="small mb-1">已叫到你囉！請前往櫃台報到：</div>
            <div class="fw-bold" id="counter-name"></div>
          </div>
        </div>

        <div class="text-muted small mt-3">
          此頁面會每 3 秒自動更新一次狀態。<br />
          若你是從 QR Code 或 LINE 開啟，可以保持這個畫面邊等邊看進度。
        </div>
      </div>
    </div>

    <script>
      // 加引號避開編輯器報錯，並用 Number() 確保它是數字格式
      const ticketId = Number("{{ ticket_id }}");
      // 透過樣板語法取得 service，也可以由後端傳入
      const serviceName = "{{ service }}";
      let myNumber = null;

      // 1. 基礎資訊載入 (第一次進來還是要查一下自己的號碼跟狀態)
      async function initStatus() {
        try {
          const res = await fetch(`/ticket/${ticketId}/status`);
          if (!res.ok) {
            document.body.innerHTML =
              "<div class='container py-5'><h2>找不到這張號碼，可能已過期。</h2></div>";
            return;
          }
          const data = await res.json();

          // 保存我的號碼，供後續計算使用
          myNumber = data.number;

          updateUI(
            data.current_number,
            data.ahead_count,
            data.status,
            data.counter
          );
        } catch (e) {
          console.error(e);
        }
      }

      // 更新畫面的通用函式
      function updateUI(currentNum, aheadCount, status, counterName) {
        // 更新目前叫號
        document.getElementById("current-number").textContent =
          currentNum ?? "尚未開始";
        document.getElementById("my-number").textContent = myNumber;

        // 計算前面還有幾人 (如果是 SSE 推播過來，我們可以用簡單數學計算，或選擇重新 fetch)
        // 為了精準，若 status 還是 waiting，我們可以簡單推算：
        if (myNumber && currentNum) {
          // 簡單邏輯：我的號碼 - 目前號碼 - 1 (正在服務的那位)
          // 但精準邏輯其實比較複雜(中間可能有人取消)，
          // 為了展示 SSE 的即時性，我們這裡做一個「觸發更新」的動作即可，
          // 或者直接顯示簡單數學。

          // 這裡我們採用混合策略：收到 SSE 通知後，立刻更新「目前叫號」，
          // 然後在背景安靜地 fetch 一次最新精準狀態 (因為 ahead_count 比較難純前端算)
          document.getElementById("status-badge").textContent =
            status === "serving" ? "服務中" : "等待中";
        }

        // 顯示櫃台資訊
        if (status === "serving" && counterName) {
          document.getElementById("counter-info").style.display = "block";
          document.getElementById("counter-name").textContent = counterName;
          document.getElementById("status-badge").textContent = "服務中";
          document.getElementById("status-badge").className =
            "badge bg-success";
          // 叫到我了，前面當然是 0 人
          document.getElementById("ahead-count").textContent = "0";
        } else if (status === "done") {
          document.getElementById("status-badge").textContent = "已完成";
          document.getElementById("ahead-count").textContent = "0";
        } else {
          document.getElementById("counter-info").style.display = "none";
          if (aheadCount !== undefined) {
            document.getElementById("ahead-count").textContent = aheadCount;
          }
        }
      }

      // 2. 啟動 SSE 監聽 (這才是「即時」的靈魂)
      // 連接到 app.py 定義的 /events/<service>
      const evtSource = new EventSource(`/events/${serviceName}`);

      evtSource.onmessage = function (event) {
        // 當櫃台按下「叫下一位」時，後端會推播 JSON 字串
        // 格式參考 app.py: {"ticket_id": ..., "number": ..., "counter": ...}
        const msg = JSON.parse(event.data);
        console.log("收到即時叫號通知:", msg);

        const calledNumber = msg.number;
        const calledCounter = msg.counter;
        const calledTicketId = msg.ticket_id;

        // 更新「目前叫號」顯示
        document.getElementById("current-number").textContent = calledNumber;

        // 判斷是不是叫到我
        if (calledTicketId === ticketId) {
          // 叫到我了！
          updateUI(calledNumber, 0, "serving", calledCounter);
          // 可以加一個震動或音效 (Mobile only)
          if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
        } else {
          // 叫到別人，我還在等
          // 策略：收到事件後，稍等 0.5 秒重新抓取精確的 ahead_count
          // 這樣既有即時感，資料又準確
          setTimeout(initStatus, 500);
        }
      };

      // 初始執行一次
      initStatus();
    </script>
  </body>
</html>
